{% extends 'layouts/layout_base.html' %}

{% block css.custom %}
  <link rel='stylesheet' href='/static/css/reachable.css'>
  <style>
  </style>
{% endblock css.custom %}

{% block body_content %}
<div id="main" class="panel panel-default">
  <div class="panel-heading"><i class="glyphicon glyphicon-dashboard"></i> Reachable Query Generator</div>
  <template v-if="input">
    <div class="row">
      <div class="col-sm-4">
        <div class="panel panel-default" style="margin-left: 5px; margin-right: 0px; margin-top: 5px;">
          <div class="panel-heading"><i class="glyphicon glyphicon-cog"></i> Query Parameters</div>
          <div class="panel-body">
            <div class="col-sm-5">
              <label>Source Path:</label>
              <input type="text" class="form-control" v-model="analysis.source"/>
            </div>
            <div class="col-sm-2">
              <span>&#x27F6;</span>
            </div>
            <div class="col-sm-5">
              <label>Target Path:</label>
              <input type="text" class="form-control" v-model="analysis.target"/>
            </div>

            <div class="col-sm-12" style="margin-top: 10px;">
              <div>
                <label>Analysis Type:</label>
              </div>
              <div class="btn-group" data-toggle="buttons">
                <label class="btn btn-default active">
                  <input type="radio"  name="analysis_type" value="0" checked="checked"/> Dead Code
                </label>
                <label class="btn btn-default disabled">
                  <input type="radio" name="analysis_type" value="1" /> Reach Code
                </label>
              </div>
            </div>

          </div>
        </div>
      </div>

      <div class="col-sm-4">
        <div class="panel panel-default" style="margin-left: 0px; margin-right: 0px; margin-top: 5px;">
          <div class="panel-heading"><i class="glyphicon glyphicon-book"></i> Query Data Basis</div>
          <div class="panel-body">
            <div>
              <label>Mozsearch Index:</label>
              <select class="form-control" v-model="mozsearch.selected">
                <option :value="option" v-for="option in mozsearch.options">
                  !{ option.created }! - !{ option.os }!
                </option>
              </select>
            </div>
          </div>
        </div>
      </div>

      <div class="col-sm-4">
        <div class="panel panel-default" style="margin-left: 0px; margin-right: 5px; margin-top: 5px;">
          <div class="panel-heading"><i class="glyphicon glyphicon-info-sign"></i> Description</div>
          <div class="infotext">
            <span>Reachable allows you to perform certain types of analysis based on the dependency graph data generated
            for Searchfox during each build of mozilla-central. For this purpose, you specify a source location and a
            target location, each of them referring to a path or file in mozilla-central. Leaving the source location
            empty means all of mozilla-central can be the source, except the target itself. </span>
          </div>
          <div class="infotext">
            <span>Currently, only one type of analysis is implemented: The <b>dead code</b> analysis. With this analysis
            type, all clusters and isolated files within the target that are not reachable from the source will be
            outlined. One potential use case for this analysis result is to prevent these files from being built in the
            first place by eithe deleting them from the codebase or removing them from the respective moz.build files.
            Clusters found by this analysis typically have the property that they can only be removed together.</span>
            </div>
          </div>
        </div>
      </div>

      <div class="row">
        <div class="col-sm-4">
          <button @click="analysis_precheck()" class="btn btn-default">Run Analysis</button>
        </div>
      </div>
    </template>
    <template v-else>
      <div class="panel-body">
        <template v-if="loading">
          <div class="col-sm-8 tile">
            <div class="loader"></div>
            <template v-if="loading_incomplete">
              <div class="loader-msg">
                <span>The requested query result is being generated by the server, please wait...</span>
              </div>
            </template>
          </div>
        </template>
        <template v-else>
          <div id="graph-container" class="col-sm-8 sbs"><svg></svg></div>
        </template>
        <div class="col-sm-4" style="height: 75vh;">

          <div class="panel panel-default">
            <div class="panel-heading"><i class="glyphicon glyphicon-info-sign"></i> Status information</div>
            <div class="infotext" ref="progress_panel" style="height: 15vh; overflow-y: scroll;">
              <p class="console" style="white-space: pre-line;">
                !{ progress }!<span class="blinking-cursor">&#x2589;</span>
              </p>
            </div>
          </div>

          <div class="panel panel-default">
            <div class="panel-heading"><i class="glyphicon glyphicon-info-sign"></i> Analysis Results</div>
            <div class="infotext" style="height: 45vh; overflow-y: scroll;">
              <template v-if="isolates">
                <div># Isolates</div>
                <div v-for="isolate in filtered_isolates">!{ isolate }!</div>

                <div v-for="cluster in filtered_clusters">
                  <div style="margin-top: 12px"># Cluster</div>
                  <div v-for="isolate in cluster">
                    !{ isolate }!
                  </div>
                </div>
              </template>
            </div>
          </div>

        </div>
      </div>
    </template>
  </div>

<script>
let URLS = {
  rgapi : '{% url 'reachable:query_result_graph_api' %}',
  capi : '{% url 'reachable:query_compute_api' %}',
  msiapi : '{% url 'reachable:mozsearchindex_list_api' %}',
  qapi : '{% url 'reachable:query_list_api' %}',
  qcapi : '{% url 'reachable:query_create_api' %}',
  rapi : '{% url 'reachable:result_list_api' %}',
}

let pmanager = new HashParamManager()

let covmanager = new Vue({
  el: '#main',
  data: {
    csrftoken: "",
    input: true,
    loading: false,
    loading_incomplete: false,
    result_id: null,
    chart: null,
    analysis: {
      id: null,
      source: "",
      target: "",
      type: 0,
    },
    mozsearch: {
      selected: null,
      options: [],
    },
    progress: "",
    filter_headers: true,
    isolates: false,
    clusters: [],
  },
  updated: function () {
    let self = this
    this.$nextTick(function () {
      if (self.progress) {
        let el = this.$refs.progress_panel
        el.scrollTop = el.clientHeight
      }
    })
  },
  watch: {
    'chart': function() {
      this.draw()
    },
    'result_id': function() {
      if (this.result_id != null) {
        this.fetch()
      }
    }
  },
  created: function () {
    this.csrftoken = getCSRFToken()
    this.fetch_msi()
  },
  computed: {
    filtered_isolates: function() {
      if (this.filter_headers)
        return this.isolates.filter(e => !(e.endsWith(".h") || e.endsWith(".hxx")));
      return this.isolates
    },
    filtered_clusters: function() {
      if (this.filter_headers) {
        let ret = []
        for (const c of this.clusters)
          ret.push(c.filter(e => !(e.endsWith(".h") || e.endsWith(".hxx"))));
        return ret
      }
      return this.clusters
    },
  },
  methods: {
    fetch: _.throttle (function () {
      this.loading = true
      this.input = false
      fetch(URLS.rgapi + "?qrid=" + this.result_id, {
        method: 'GET',
        credentials: 'same-origin'
      }).then(response => {
        if (response.ok) {
          if (response.status == 202) {
            response.text().then(txt => {
              try {
                json = JSON.parse(txt)
              } catch(exc) {}
              if (json)
                this.progress = json['progress']
            })

            // Query is still being processed, retry in a few
            setTimeout(this.fetch, 1000)
            this.loading_incomplete = true
            return;
          }
          this.loading_incomplete = false
          this.loading = false
          return response.json()
        }
        sweetAlert('Oops', E_SERVER_ERROR, 'error')
        this.loading = false
      }).then(json => {
        if (json) {
          if ("error" in json) {
            sweetAlert('Configuration Error', json["error"], 'error')
            return
          }

          if ("warning" in json) {
            sweetAlert('Configuration Warning', json["warning"], 'warning')
          }

          this.progress = json['progress']
          this.clusters = json['result']['clusters']
          this.isolates = json['result']['isolates']
          this.chart = json["d3_graph"]
        }
      })
    }, 500),
    fetch_msi: function() {
      var self = this
      this.loading = true

      return fetch(URLS.msiapi, {
        method: 'GET',
        credentials: 'same-origin',
      })
      .then(response => {
        if (response.ok) {
          return response.json()
        }
        sweetAlert('Oops', E_SERVER_ERROR, 'error')
      }).then(json => {
        this.mozsearch.options = json['results']

        linux_only = this.mozsearch.options.filter(e => e.os == "linux");
        if (linux_only) {
          this.mozsearch.selected = linux_only[linux_only.length - 1]
        }

        this.loading = false
      })
    },
    analysis_precheck: function() {
      var self = this
      this.loading = true

      let rquery = JSON.stringify({
        "op" : "AND",
        "query__target_path" : this.analysis.target,
        "query__source_path" : this.analysis.source,
        "query__type" : this.analysis.type,
        "indexfiles" : this.mozsearch.selected.id,
      })

      let qquery = JSON.stringify({
        "op" : "AND",
        "target_path" : this.analysis.target,
        "source_path" : this.analysis.source,
        "type" : this.analysis.type,
      })

      return fetch(URLS.rapi + "?query=" + rquery, {
        method: 'GET',
        credentials: 'same-origin',
      })
      .then(response => {
        if (response.ok) {
          return response.json()
        }
        sweetAlert('Oops', E_SERVER_ERROR, 'error')
      }).then(json => {
        if(json['count'] > 0) {
          // There is a result cached, directly load it
          let results = json["results"]
          self.result_id = results[results.length - 1].id
        } else {
          fetch(URLS.qapi + "?query=" + qquery, {
            method: 'GET',
            credentials: 'same-origin',
          })
          .then(response => {
            if (response.ok) {
              return response.json()
            }
            sweetAlert('Oops', E_SERVER_ERROR, 'error')
          }).then(json => {
            this.loading = false

            if(json['count'] > 0) {
              let results = json["results"]
              self.analysis.id = results[results.length - 1].id
              self.run_analysis()
            } else {
              self.create_and_run_query()
            }
          })
        }
      })
    },
    create_and_run_query: function() {
      var self = this

      sweetAlert({
        title: "Create Query",
        text: 'Enter a query description',
        type: 'input',
        showCancelButton: true,
        animation: "slide-from-top"
      }, function(description){
        let data = {
          "description" : description,
          "target_path" : self.analysis.target,
          "source_path" : self.analysis.source,
          "type" : self.analysis.type,
        }

        return fetch(URLS.qcapi, {
          method: 'POST',
          credentials: 'same-origin',
          headers: {
            "Content-Type": "application/json; charset=utf-8",
            "X-Requested-With": "XMLHttpRequest",
            "X-CSRFToken": self.csrftoken
          },
          body: JSON.stringify(data),
        })
        .then(response => {
          if (response.ok) {
            return response.json()
          }
          sweetAlert('Oops', E_SERVER_ERROR, 'error')
        })
        .then(json => {
          self.analysis.id = json["id"]
          self.run_analysis()
        })
      })
    },
    run_analysis: function() {
      var self = this

      let data = {
        "queryid" : self.analysis.id,
        "mozindexid" : self.mozsearch.selected.id,
      }

      return fetch(URLS.capi, {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          "Content-Type": "application/json; charset=utf-8",
          "X-Requested-With": "XMLHttpRequest",
          "X-CSRFToken": this.csrftoken
        },
        body: JSON.stringify(data),
      })
      .then(response => {
        if (response.ok) {
          return response.json()
        }
        sweetAlert('Oops', E_SERVER_ERROR, 'error')
      })
      .then(json => {
        self.result_id = json["newid"]
      })
    },
    draw: function() {
      let self = this
      let data = this.chart
      if (!data) return;

      let chartDiv = document.getElementById("graph-container");
      let colors = d3.scaleOrdinal(d3.schemeCategory10);
      let width = chartDiv.clientWidth;
      let height = chartDiv.clientHeight;

      let radius = 6;

      let svg = d3.select("svg")

      svg.remove();

    	d3.select("#graph-container")
            .append("svg:svg")
            .attr("width", width)
            .attr("height", height)
            .style("border", "2px")

      svg = d3.select("svg")

      svg.attr("viewBox", [-width / 2, -height / 2, width, height])

      svg.append('defs').append('marker')
          .attrs({'id':'arrowhead',
              'viewBox':'-0 -5 10 10',
              'refX':13,
              'refY':0,
              'orient':'auto',
              'markerWidth':13,
              'markerHeight':13,
              'xoverflow':'visible'})
          .append('svg:path')
          .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
          .attr('fill', '#999')
          .style('stroke','none');

      let nodes = data["nodes"]
      let links = data["links"]

      var simulation = d3.forceSimulation()
          .force("link", d3.forceLink().id(function (d) {return d.id;}).distance(100))
          .force("charge", d3.forceManyBody().strength(-500))
          .force("x", d3.forceX())
          .force("y", d3.forceY())

      const link = svg.append("g")
          .attr("stroke", "#999")
          .attr("stroke-opacity", 0.6)
          .selectAll("line")
          .data(links)
          .enter().append("line")
          .attr("class", "link")
          .attr('marker-end','url(#arrowhead)')
          .attr("stroke-width", d => Math.sqrt(d.value));

      link.append("title")
          .text(function (d) {return d.type;});

      drag = simulation => {
            function dragstarted(d) {
              if (!d3.event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
            }

            function dragged(d) {
              d.fx = d3.event.x;
              d.fy = d3.event.y;
            }

            function dragended(d) {
              if (!d3.event.active) simulation.alphaTarget(0);
              d.fx = null;
              d.fy = null;
            }

            return d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);
      }

      const node = svg.selectAll(".node")
          .data(nodes)
          .enter()
          .append("g")
          .attr("class", "node")
          .call(drag(simulation));


      node.append("circle")
          .attr("r", 5)
          .style("fill", function (d, i) {return colors(i);})


      node.append("title")
          .text(function (d) {return d.id;});

      node.append("text")
          .attr("dy", -3)
          .text(function (d) {return d.label;});


      node.append("title")
          .text(d => d.id);

      simulation.nodes(nodes).on("tick", () => {
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        node
            .attr("transform", function (d) {return "translate(" + d.x + ", " + d.y + ")";});

        node
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);

        // TODO: Fix bounding
        /*node
            .attr("cx", d => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr("cy", d => d.y = Math.max(radius, Math.min(height - radius, d.y)));
            */
      });

      simulation.force("link").links(links);
    },
  },
})

// This updates our path variable in the Vue whenever the hash changes, which again triggers a reload of the data.
window.onhashchange = function() {
  pmanager.update_state()
}
</script>

{% endblock body_content %}
